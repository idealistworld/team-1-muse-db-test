# Project Name: Muse - Team 1

## Database Design


Table containing constraints, pk, fk, etc. extra information

https://docs.google.com/spreadsheets/d/1CksnrYIqFs90kd9xkaRTjEDNLkYb8VTkrjm9DpjtiEo/edit?gid=2144144581#gid=2144144581

**Primary Keys**

UUIDs on all user-owned tables (user_profiles, user_posts, user_media, user_follows).

BIGINT IDENTITY on catalog/ingest tables (creator_profiles, creator_content, post_inspirations).

**Foreign Keys**

All relationship columns (e.g. user_id, creator_id, post_id, content_id) are foreign keys with cascading deletes to maintain referential integrity.

**Timestamps**

Every table has created_at and updated_at. A touch_updated_at() trigger automatically refreshes updated_at on any modification, ensuring lifecycle accuracy without extra app logic.

**Constraints & Uniqueness**

subscription_tier is restricted to free or pro (enum-style check).

Creator profiles are case-insensitive unique on (LOWER(platform), LOWER(profile_url)).

Linking tables enforce uniqueness:

(user_id, creator_id) in user_follows → no duplicate follows.

(post_id, content_id) in post_inspirations → no duplicate inspiration links.

### Overview
Muse is a tool that helps users craft more engaging LinkedIn posts by analyzing trending creator content, identifying effective patterns, and suggesting improvements. It looks at tone, structure, hashtags, and engagement hooks from the people you follow—then applies those insights to your own drafts.

What the Database Does

The database is the backbone of Muse. It keeps track of all the moving pieces that make the analysis possible:

User data – Each user’s profile, posts, and any media they upload.

Creator catalog – Profiles and posts from LinkedIn creators that Muse ingests for trend analysis.

Social graph – Who follows whom, linking users to the creators they care about.

Inspiration links – A special table that ties a user’s draft post to the creator content that inspired it, giving transparency and context.


### Entity Relationship Diagram

![ER Diagram](./docs/er-diagram.png)

### Tables Description

- **user_profiles**: Stores user account information

  - `user_id` (UUID, PK): Unique user identifier
  - `subscription_tier` (TEXT): Either 'free' or 'pro'
  - `created_at`, `updated_at` (TIMESTAMPTZ): Auto-managed timestamps

- **creator_profiles**: Stores external creators that users can follow

  - `creator_id` (BIGINT, PK): Auto-incrementing ID (GENERATED ALWAYS)
  - `profile_url` (TEXT): Creator's profile URL (must start with http:// or https://)
  - `platform` (TEXT): Social media platform
  - `created_at`, `updated_at` (TIMESTAMPTZ): Auto-managed timestamps
  - Unique index on lowercased `(platform, profile_url)` combination

- **creator_content**: Stores posts/content from creators

  - `content_id` (BIGINT, PK): Auto-incrementing ID (GENERATED BY DEFAULT)
  - `creator_id` (BIGINT, FK): References creator_profiles
  - `post_url` (TEXT): URL to the creator's post
  - `post_raw` (TEXT): Raw content text (optional)
  - `created_at`, `updated_at` (TIMESTAMPTZ): Auto-managed timestamps
  - Cascade delete when creator is deleted

- **user_posts**: Stores posts created by users

  - `post_id` (UUID, PK): Auto-generated UUID
  - `user_id` (UUID, FK): References user_profiles
  - `raw_text` (TEXT): Post content (optional)
  - `created_at`, `updated_at` (TIMESTAMPTZ): Auto-managed timestamps
  - Cascade delete when user is deleted

- **user_media**: Stores media attachments for user posts

  - `user_media_id` (UUID, PK): Unique media identifier
  - `post_id` (UUID, FK): References user_posts
  - `media_url` (TEXT): URL to media file
  - `media_type` (TEXT): Type of media (optional)
  - `created_at`, `updated_at` (TIMESTAMPTZ): Auto-managed timestamps
  - Cascade delete when post is deleted

- **user_follows**: Tracks which creators users follow

  - `id` (UUID, PK): Auto-generated UUID
  - `user_id` (UUID, FK): References user_profiles
  - `creator_id` (BIGINT, FK): References creator_profiles
  - `created_at` (TIMESTAMPTZ): When the follow occurred
  - Unique constraint on `(user_id, creator_id)` pair
  - Cascade delete when user or creator is deleted

- **post_inspirations**: Links user posts to creator content that inspired them
  - `id` (BIGINT, PK): Auto-incrementing ID (GENERATED ALWAYS)
  - `post_id` (UUID, FK): References user_posts
  - `content_id` (BIGINT, FK): References creator_content
  - `created_at`, `updated_at` (TIMESTAMPTZ): Auto-managed timestamps
  - Unique constraint on `(post_id, content_id)` pair
  - Cascade delete when post or content is deleted

### Security Model

Our RLS policies are built around two core principles:

1. **Authentication Required**: All data access requires a signed-in user. This is a private platform for solopreneurs managing their content workflow—not a public site. Anonymous users get nothing.

2. **Users Own Their Rows**: Once authenticated, users can only read/write rows they own. This prevents any user from tampering with another user's profiles, posts, media, follows, or inspirations.

#### Detailed Policy Breakdown

**user_profiles**

- **SELECT** (`user_profiles_select_self`): `user_id = auth.uid()` - Users can only view their own profile, preventing PII leakage across accounts
- **INSERT** (`user_profiles_insert_self`): WITH CHECK ensures `user_id = auth.uid()` - Users can only create their own profile, blocks forging profiles for other users
- **UPDATE** (`user_profiles_update_self`): Both USING and WITH CHECK verify `user_id = auth.uid()` - Prevents ownership flips during updates (can't change your profile to belong to someone else)
- **DELETE** (`user_profiles_delete_self`): `user_id = auth.uid()` - Users can only delete their own profile

**user_posts**

- **SELECT** (`user_posts_select_own`): `user_id = auth.uid()` - Scopes posts to owner, nobody sees another user's drafts
- **INSERT** (`user_posts_insert_self`): WITH CHECK `user_id = auth.uid()` - Posts must be attributed to the creator
- **UPDATE** (`user_posts_update_own`): Both checks prevent reassigning posts to different users mid-update
- **DELETE** (`user_posts_delete_own`): `user_id = auth.uid()` - Only owner can delete their posts

**user_media**

- **SELECT** (`user_media_select_via_post`): `EXISTS (SELECT 1 FROM user_posts p WHERE p.post_id = user_media.post_id AND p.user_id = auth.uid())` - Media viewable only if parent post belongs to requesting user
- **INSERT** (`user_media_insert_via_post`): WITH CHECK validates ownership through parent post - Prevents attaching media to other users' posts
- **UPDATE** (`user_media_update_via_post`): Both USING and WITH CHECK verify ownership - Media must stay attached to your own post
- **DELETE** (`user_media_delete_via_post`): Verified through parent post ownership

**user_follows**

- **SELECT** (`user_follows_select_self`): `user_id = auth.uid()` - Users only see their own follow graph
- **INSERT** (`user_follows_insert_self`): WITH CHECK `user_id = auth.uid()` - Can only follow creators as yourself, prevents forging follow rows for others
- **DELETE** (`user_follows_delete_self`): `user_id = auth.uid()` - Can only unfollow from your own rows

**post_inspirations**

- **SELECT** (`post_insp_select_via_post`): `EXISTS` check through `user_posts` - Only view inspirations for your own posts
- **INSERT** (`post_insp_insert_via_post`): WITH CHECK validates post ownership - Prevents linking someone else's post to creator content
- **DELETE** (`post_insp_delete_via_post`): Verified through parent post ownership

**creator_profiles** & **creator_content**

- **All Operations**: Require `auth.role() = 'authenticated'`
- Prevents anonymous scraping of the creator directory
- All authenticated users can currently add/edit. We might want to allows users to upload content they find online manually, but this is subject to change.

## Setup Instructions

### Prerequisites

- Python 3.10+
- Supabase account
- pip (Python package manager)
- Relevant libraries:
  - `supabase` - Supabase Python client
  - `python-dotenv` - Environment variable management
  - `httpx` - HTTP client for API requests
  - `postgrest` - Turns PostgreSQL database into instant REST API

### Installation

1. Install required packages:

```bash
pip install supabase python-dotenv httpx postgrest
```

2. Copy `.env.example` to `.env` and configure:

```bash
cp .env.example .env
```

3. Update `.env` with your Supabase credentials:

```
SUPABASE_URL=https://your-project-id.supabase.co
SUPABASE_ANON_KEY=your-anon-key-here

# Test user credentials (for authenticated testing)
TEST_USER_EMAIL=your-test-email@example.com
TEST_USER_PASSWORD=your-test-password
```

### Running the test scripts

Run the connection test:

```bash
python3 test_connection.py
```

When prompted, choose:

- `y` to run authenticated tests (uses credentials from `.env`)
- `n` to run anonymous tests only
